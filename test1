# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pj0hyrSnyDDqhKnd4NbWRUdIidw4ZUos
"""

!pip install shap # 라이브러리 설치
import shap 
from sklearn.model_selection import train_test_split

# 데이터 불러오기
X, y = shap.datasets.boston()
X_train, X_test, y_train, y_test = train_test_split(X, y,
                                                    test_size = 0.2,
                                                    random_state = 1)
X_train[:10]

# Commented out IPython magic to ensure Python compatibility.
# plot library
import matplotlib.pylab as plt
import matplotlib


# %matplotlib inline
matplotlib.style.use('ggplot')

fig, ax1 = plt.subplots(1, 1, figsize = (12, 6))


ax1.scatter(X['RM'], # x축 변수
            y, # y 축 변수
            color = 'black', # 점 색깔
            alpha = 0.6 # 불투명도 
            )

ax1.set_title('Title') # 제목
ax1.set_xlim(2.5, 9) # 표시할 x축 범위
ax1.set_xlabel("RM") # x축 label
ax1.set_ylim(0, 55) # 표시할 y축 범위
ax1.set_ylabel("MEDV \n Price $1,000") # y축 label

from sklearn import linear_model
import pandas as pd

linear_regression = linear_model.LinearRegression()
linear_regression.fit( X = pd.DataFrame(X_train["RM"]), 
                                        y = y_train)
prediction = linear_regression.predict(X = pd.DataFrame(X_test['RM']))

print('a value : ', linear_regression.intercept_)
print('b value : ', linear_regression.coef_)
f"MEDV =  {linear_regression.coef_[0] : .2f} * RM {linear_regression.intercept_ : .2f}"

fig, ax1 = plt.subplots(1, 1, figsize = (12, 6)) 

# train scatter
ax1.scatter(X_train['RM'], # x축 변수
            y_train, # y 축 변수
            color = 'black', # 점 색깔
            alpha = 0.6, # 불투명도 
            label = 'train_data') # plot에 label을 달아서 범례에 활용
# test scatter
ax1.scatter(X_test['RM'], # x축 변수
            y_test, # y 축 변수
            color = '#993299', # 점 색깔
            alpha = 0.6, # 불투명도 
            label = 'test_data')

# regression line
ax1.plot(X_test['RM'],
         prediction,
         color = 'purple',
         alpha = 1,
         linestyle = '--',
         label = "linear regression line")

ax1.set_title('Title') # 제목
ax1.set_xlim(2.5, 9) # 표시할 x축 범위
ax1.set_xlabel("RM") # x축 label
ax1.set_ylim(0, 55) # 표시할 y축 범위
ax1.set_ylabel("MEDV \n Price $1,000") # y축 label

ax1.legend()

# rmse 구하기
# 조금 이상한듯??
from sklearn.metrics import mean_squared_error
import numpy as np

rmse = np.sqrt( mean_squared_error(y_test, prediction, squared=False))
rmse

np.sqrt(sum( (y_test - prediction) ** 2 )) / len(y_test)

import xgboost

model = xgboost.XGBRegressor(objective = 'reg:linear')
model.fit(X_train, y_train)

preds = model.predict(X_test)

np.sqrt(sum( (y_test - preds) ** 2 )) / len(y_test)

shap.initjs()
explainer = shap.TreeExplainer(model)
shap_values = explainer.shap_values(X_train)

shap.force_plot(explainer.expected_value,
                shap_values[0, :],
                X_train.iloc[0, :])

np.array(y_train - linear_regression.predict(X = pd.DataFrame(X_train["RM"] ) )).argmax()

fig, ax1 = plt.subplots(1, 1, figsize = (12, 6)) 

# scatter
ax1.scatter(X['RM'], # x축 변수
            y, # y 축 변수
            color = 'black', # 점 색깔
            alpha = 0.6, # 불투명도 
            label = 'train_data') # plot에 label을 달아서 범례에 활용
# outlier
idx = 259
ax1.scatter(X_train['RM'].iloc[idx], # x축 변수
            y_train[idx], # y 축 변수
            color = 'red', # 점 색깔
            s = 150, # 불투명도 
            label = 'outlier')

ax1.set_title('Title') # 제목
ax1.set_xlim(2.5, 9) # 표시할 x축 범위
ax1.set_xlabel("RM") # x축 label
ax1.set_ylim(0, 55) # 표시할 y축 범위
ax1.set_ylabel("MEDV \n Price $1,000") # y축 label

## plot에 text를 표시하는 명령어는??

# 259번에 대한 섀플리 영향도
shap.initjs()

shap.force_plot(explainer.expected_value,
                shap_values[259, :],
                X_train.iloc[259, :])

# 전체 데이터에 대한 영향도 그래프
shap.initjs()
shap.force_plot(explainer.expected_value,
                shap_values,
                X_train)

# 위에 있는 드롭다운 바는 정렬하는 방식,

# 옆에 있는 드롭다운 바는 관심있는 변수만 보는 것

shap.dependence_plot("RM",
                     shap_values,
                     X_train)

shap.summary_plot(shap_values,
                  X_train)
